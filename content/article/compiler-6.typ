
#import "/typ/templates/blog.typ": *
#show: main.with(
  title: "Compiler CheetSheet VI",
  desc: [编译原理课程考试前的一些总结. Ch1,Ch2],
  date: "2025-06-20",
  tags: (
    blog-tags.exam,
    blog-tags.compiler,
  ),
  show-outline: true,
)

这两章基本都是定义与概念

= Chapter01概述
重点掌握
- 编译的基本概念
- 编译程序的功能和结构
- 编译的完整流程的各个阶段
- 以及他们怎样作为一个整体完成编译任务

== From源代码to可执行文件
以C语言为例

+ 预处理阶段
  - 源文件-->预处理文件
+ 编译阶段
  - 预处理文件-->汇编代码文件
+ 汇编阶段
  - 汇编代码文件-->目标代码文件/机器指令
+ 连接阶段
  - 目标文件--->可执行文件

#figure(image("../../public/blog-resources/image-42.png"))

== 编译的过程
+ 前端：对源程序，识别语法结构信息，理解语义信息，反馈出错信息
  - 词法分析
  - 语法分析
  - 语义分析
+ 后端：综合分析结果，生成语义上等价于源程序的目标程序
  - 中间代码生成
  - 中间代码优化
  - 目标代码生成

例题：说明以下错误是在编译的哪个阶段（词法分析、语法分析、语义分析、代码生成）报告的
+ else 没有匹配 if ===> 语法分析
+ 数组下标越界 ===> 语义分析,代码生成
+ 使用函数没有定义 ===> 语义分析
+ 数字中出现非数字字符 ===> 语法分析

= Chapter02语言和文法

== 相关定义
- 字母表(符号集)：是元素的非空有穷集合
- 符号串：是由字母表中的符号组成的任何有穷序列
- 语言：Σ\*上任意字符串的集合均是该字母表Σ上的语言
- 文法：$G=(V_N, V_T, P, S)$
  - $V_N$：非终结符集合
  - $V_T$：终结符集合
  - $P$：产生式集合
  - $S$：开始符号
- 推导与规约
  - 直接推导/直接规约：一步 (v => w)
  - 多步: v =+> w
  - 零步或多步: v=\*>w
  - 最右推导是规范推导
- 句型：由文法开始符号S推导出的任意符号串α
- 句子：仅由终结符组成的句型α
- 语言：文法G[S]的一切句子的集合称为文法的语言
- 0型文法：任何文法都是0型文法。
- 1型文法：上下文有关文法，对P中的任一产生式α->β，都有|β|≥|α|，仅S->ε除外
- 2型文法：上下文无关文法，2型文法产生式的一般形式是：A->β，它表示不管A的上下文如何即可把A替换成β，因此被称为上下文无关文法。
- 3型文法：正规文法，产生式全部是规定的形式
#figure(image("../../public/blog-resources/image-43.png"))

== 为串的生成构造语法树
例题
#figure(image("../../public/blog-resources/image-44.png"))

二义性：同样的串可以由两个不同的最左/最右推导过程得到

== 短语，直接短语和句柄
短语：设αβδ是文法G[S]中的一个句型，如果有S=\*>αAδ且A=+>β，则称β是句型αβδ相对于非终结符A的短语[phrase]。

特别的如有A=>β，则称β是句型αβδ相对于规则A→β的直接短语（简单短语）。

一个句型的_最左直接短语_称为该句型的句柄[Handle]。

例子：
#figure(image("../../public/blog-resources/image-45.png"))
#figure(image("../../public/blog-resources/image-46.png"))
